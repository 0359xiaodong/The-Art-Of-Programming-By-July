# 字符串转换成整数

## 题目描述
输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"345"，输出整数345。

给定函数原型`int StrToInt(const char *str)` ，实现字符串转换成整数的功能。不能使用库函数atoi。

## 分析与解法

本题考查的实际上就是字符串转换成整数的问题，或者说是要你自行实现atoi函数。那如何实现把表示整数的字符串正确地转换成整数呢？以"345"作为例子：
 - 当我们扫描到字符串的第一个字符'3'时，由于我们知道这是第一位，所以得到数字3。
 - 当扫描到第二个数字'4'时，而之前我们知道前面有一个3，所以便在后面加上一个数字4，那前面的3相当于30，因此得到数字：3*10+4=34。
 - 继续扫描到字符'5'，'5'的前面已经有了34，由于前面的34相当于340，加上后面扫描到的5，最终得到的数是：34*10+5=345。

因此，此题的基本思路便是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。  

但有一些细节需要注意：  
1. 正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。  
2. 空指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。  
3. 非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。  
4. 整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。  

上述其它问题比较好处理，但溢出问题比较麻烦，所以咱们先来解决溢出问题，解决了溢出问题，其它便好说了。

一般说来，当发生溢出时，取最大或最小的int值。例如，大于正整数能表示的范围返回MAX_INT：2147483647；小于负整数能表示的范围返回MIN_INT：-2147483648。

我们先设置一些变量：
 - signal表示数字的符号，'+'或'-'
 - res存放最终转换后的结果
 - cur表示当前数字

而后，你可能会编写如下代码段处理溢出问题：
```c
//当发生正溢出时，返回INT_MAX；
if ((signal == '+') && (cur > MAX_INT - res * 10))
{
	
	res = MAX_INT;
	break;
}
//发生负溢出时，返回INT_MIN
else if ((signal == '-') && (cur - 1 > MAX_INT - res * 10))
{
	res = MIN_INT;
	break;
}
```
但当上述代码转换"    10522545459"时出错，为何呢？因为此时已经溢出，程序结果理应得到MAX_INT：2147483647，但程序运行结果却是：1932610867。所以程序没有解决好溢出问题。

之所以会出错，是因为当给定字符串"    10522545459"时，除去空格有11位，而MAX_INT是2147483647，是10位数，即MAX_INT(2147483647) < res*10(1052254545\*10)，所以当扫描到最后一个字符‘9’的时候，执行上面的这行代码：
```c
cur > MAX_INT - res * 10
```
已无意义，因为此时(MAX_INT - res * 10)已经小于0，程序已经出错。

上面给的程序之所以没有很好的解决溢出问题，是因为由于输入了一个很大的数字转换之后会超过能够表示的最大的整数而溢出”。而一个取巧的方式是把返回的值result定义成了long long。但这样明显不符合我们心中的预期。

根据我们最初的思路：“从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字”，相信读者已经觉察到，在扫描到最后一个字符的时候，如果之前得到的数比较大，此时若再让其扩大10倍，相对来说是比较容易溢出的。  

但车到山前必有路，既然让一个比较大的int整型数括大10倍，比较容易溢出， 那么在不好判断是否溢出的情况下，可以尝试使用除法：

1. 与其将res扩大10倍,，冒着溢出的风险, 再与MAX_INT进行比较（如果已经溢出, 则比较的结果没有意义），  
2. 不如未雨绸缪先用res与MAX_INT/10进行比较： 若res>MAX_INT/10（当然同时还要考虑res == MAX_INT/10的情况），说明最后一步转换时，让res*10一定大于MAX_INT，故最终一定会溢出，所以此时可以当即进行溢出处理，直接返回最大值MAX_INT，从而也就免去了计算n\*10这一步骤。  

换句话说，计算res\*10前,先比较res与MAX_INT/10大小，若res>MAX_INT/10，那么n\*10肯定大于MAX_INT，即代表最后得到的整数n肯定溢出，既然溢出，不必也不能再计算n\*10，直接提前返回MAX_INT就行了。  

一直以来，我们努力的目的归根结底是为了更好的处理溢出，但上述做法最重要的是巧妙的规避了计算n\*10这一乘法步骤，转换成计算除法MAX_INT/10代替，不能不说此法颇妙。  

如此我们可以写出正确的处理溢出的代码：

```c
//copyright@njnu_mjn 2013
c = *str - '0';
if (sign > 0 && (n > MAX / 10 || (n == MAX / 10 && c > MAX % 10)))
{
    n = MAX;
    break;
}
else if (sign < 0 && (n > (unsigned)MIN / 10
          || (n == (unsigned)MIN / 10 && c > (unsigned)MIN % 10)))
{
    n = MIN;
    break;
}
```  
从而，字符串转换成整数，完整的参考代码为：  

```c
//copyright@njnu_mjn 2013
int StrToDecInt(const char* str)
{
    static const int MAX = (int)((unsigned)~0 >> 1);
    static const int MIN = -(int)((unsigned)~0 >> 1) - 1;
    static const int MAX_DIV = (int)((unsigned)~0 >> 1) / 10;
    static const int MIN_DIV = (int)((((unsigned)~0 >> 1) + 1) / 10);
    static const int MAX_R = (int)((unsigned)~0 >> 1) % 10;
    static const int MIN_R = (int)((((unsigned)~0 >> 1) + 1) % 10);
    int n = 0;
    int sign = 1;
    int c;

    while (isspace(*str))
        ++str;
    if (*str == '+' || *str == '-')
    {
        if (*str == '-')
            sign = -1;
        ++str;
    }
    while (isdigit(*str))
    {
        c = *str - '0';
        if (sign > 0 && (n > MAX_DIV || (n == MAX_DIV && c >= MAX_R)))
        {
            n = MAX;
            break;
        }
        else if (sign < 0 && (n > MIN_DIV
                  || (n == MIN_DIV && c >= MIN_R)))
        {
            n = MIN;
            break;
        }
        n = n * 10 + c;
        ++str;
    }
    return sign > 0 ? n : -n;
}
```
至此，虽然程序已实现题目的要求，但有一个小的问题是: 即使出错, 函数也返回了一个值, 导致调用者误认为自己传入的参数是正确的, 但是可能会导致程序的其他部分产生莫名的错误且很难调试”。如何更好的解决呢？请读者思考下。

## 类似问题

1. 实现string到double的转换

提醒：此题虽然类似于atoi函数，但毕竟double为64位，而且支持小数，因而边界条件更加严格，写代码时需要更加注意。
