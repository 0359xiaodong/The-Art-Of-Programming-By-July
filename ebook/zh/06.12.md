## simhash算法

### simhash来历

如果某一天，面试官问你如何设计一个比较两篇文章相似性的算法？可能你会回答一个比较传统的思路：即先将两篇文章进行分词，得到一系列特征向量，进而转化为特征向量距离的度量（比如常见的欧氏距离、海明距离或者夹角余弦等等），最终通过距离的大小来判断两篇文章之间的相似度。

采取这类方法，比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度呢？你还会去计算任意两个网页的距离或夹角余弦么？这时，你会开始犯愁了。

车到山前必有路，来自于Google的一篇论文“detecting near-duplicates for web crawling”提出了simhash算法，专门用来解决万亿级别的网页的去重任务。

 - simhash算法的主要思想是降维，将高维的特征向量映射成一个低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。
- 其中，Hamming Distance，又称汉明距离，在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。例如：1011101 与 1001001 之间的汉明距离是 2。

至于我们常说的字符串编辑距离则是一般形式的汉明距离。

### simhash算法流程

simhash算法分为5个步骤：分词、hash、加权、合并、降维，具体如下所述：
 - 分词
- 给定一段语句或一个文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如给定一段语句：“CSDN博客结构之法算法之道的作者July”，分词后为：“CSDN 博客 结构 之 法 算法 之 道 作者 July”，然后为每个特征向量加权：CSDN(4) 博客(5) 结构(3) 之(1) 法(2) 算法(3) 之(1) 道(2) 作者(5) July(5)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。
 - hash
- 通过hash函数计算各个特征向量的hash值，hash值为01组成的n-bit签名。比如“CSDN”的hash值为100101，“博客”的hash值为“101011”。就这样，字符串就变成了一系列数字。
 - 加权
- 在hash值的基础上，给所有特征向量进行加权（1则为正，0则为负）。例如给“CSDN”的hash值“100101”加权（“CSDN”的权值为4）得到：4 -4 -4 4 -4 4，给“博客”的hash值为“101011”通过加权（“博客”的权值为5）得到：“5 -5 5 -5 5 5”，其余特征向量类似此般操作。
 - 合并
- 将上述各个特征向量的加权结果累加，变成只有一个序列串。这里拿前两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。
 - 降维
- 对于n-bit签名的累加结果，如果>0置1，否则置0，从而得到该语句的simhash值，最终根据不同语句simhash的海明距离就来判断相似程度。例如把上面计算出来的“9 -9 1 -1 1 9” 变成01串，根据每一位大于0 记为 1，小于0 记为 0的方法，得到的01串为：“1 0 1 0 1 1”，从而形成我们最终的simhash签名。

其流程如下图所示：
![](http://dl.iteye.com/upload/attachment/437426/baf42378-e625-35d2-9a89-471524a355d8.jpg)

有兴趣的，可以继续阅读这篇文章：http://grunt1223.iteye.com/blog/964564 。
