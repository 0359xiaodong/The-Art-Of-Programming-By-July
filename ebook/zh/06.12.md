## simhash算法

### simhash来历

如果某一天，面试官问你如何设计一个比较两篇文章相似性的算法？想必你会回答一个传统的思路，即先将两篇文章进行分词，接着转化为特征向量距离的度量（比如常见的欧氏距离、海明距离或者夹角余弦等等），进而通过距离的大小来判断两篇文章之间的相似度。

采取这类方法，比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度呢？你还会去计算任意两个网页的距离或夹角余弦么？这时，你会开始犯愁了。

车到山前必有路，来自于google的一篇论文“detecting near-duplicates for web crawling”提出了simhash算法，专门用来解决万亿级别的网页的去重任务。

simhash算法的主要思想是降维，将高维的特征向量映射成一个低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。

那什么是汉明距离呢？在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。例如：1011101 与 1001001 之间的汉明距离是 2。

而我们常说的字符串编辑距离便是一般形式的汉明距离。

### simhash算法流程：
 - 分词
- 例如给定一段语句或一个文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如“CSDN博客结构之法算法之道的作者July”，分词后为CSDN 博客 结构 之 法 算法 之 道 作者 July，然后为每个特征向量加权：CSDN(4) 博客(5) 结构(3) 之(1) 法(2) 算法(3) 之(1) 道(2) 作者(5) July(5)，括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。
 - hash
- 对每一个特征向量计算hash值，hash值为01组成的n-bit签名。例如计算每个特征向量的hash值，比如“CSDN”的hash值为100101，字符串就变成了一系列数字
 - 加权
- 在hash值的基础上，给所有特征向量进行加权（1则为正，0则为负）。例如通过加权计算为：4 -4 -4 4 -4 4，“博客”的hash值为“101011”，通过加权计算为：“5 -5 5 -5 5 5”，其余特征向量类似此般操作。
 - 合并
- 将上述各个特征向量的加权结果累加，变成只有一个序列串。例如把各个特征向量的加权结果累。这里拿两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1”
 - 降维
- 对于n-bit签名的累加结果，如果>0置1，否则置0，从而得到该语句的simhash值，最终根据不同语句simhash的海明距离就来判断相似程度。例如把上面计算出来的“9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。

其流程如下图所示：
![](http://dl.iteye.com/upload/attachment/437426/baf42378-e625-35d2-9a89-471524a355d8.jpg)
