##奇偶调序

### 题目描述
输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为O(n)。

### 分析与解法

最容易想到的办法是从头扫描这个数组，每碰到一个偶数时，拿出这个数字，并把位于这个数字后面的所有数字往前挪动一位。挪完之后在数组的末尾有一个空位，这时把该偶数放入这个空位。由于碰到一个偶数，需要移动O(n)个数字，所以这种方法总的时间复杂度是O(n^2)，不符合要求。

事实上，若把奇数看做是小的数，偶数看做是大的数，那么按照题目所要求的奇数放在前面偶数放在后面，就相当于小数放在前面大数放在后面，联想到快速排序中的partition过程，不就是通过一个主元元素把整个数组分成大小两个部分么，小于主元的小数放在前面，大于主元的小数放在后面。

而partition过程有以下两种实现
 - 一头一尾两个指针，往中间扫描，如果头指针遇到的数比主元大且尾指针遇到的数比主元小，则交换头尾指针所分别指向的数；
 - 一前一后两个指针，同时从前往后扫，如果前指针遇到的数比主元小，则后指针后移一位，然后交换各自所指向的元素。

类似这个partition过程，奇偶排序问题也可以分别借鉴partition的两种实现解决。 

为何？比如partition的实现一中，如果最终是为了让整个序列元素从小到大排序，那么头指针理应指向的就是小的元素，而尾指针理应指向的就是大的元素，故当头指针指的是大元素且尾指针指的是小元素的时候就不正常，此时就当交换。

#### 解法二

借鉴partition的实现一，我们可以考虑维护两个指针，一个指针指向数组的第一个数字，我们称之为头指针，向后移动；一个指针指向最后一个数字，称之为尾指针，向前移动。如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，我们就交换这两个数字。

因为按照题目要求，最终是为了让奇数排在数组的前面，偶数排在数组的后面，所以头指针理应指向的就是奇数元素，尾指针理应指向的就是偶数元素，所以，当头指针指向的是偶数元素且尾指针指向的是奇数时，我们就当立即交换它们所指向的元素。

例如对2 1 3 4 6 5 7进行奇偶排序，过程如下：

 2 1 3 4 6 5 7   
 7 1 3 4 6 5 2  
 7 1 3 5 6 4 2  

思路有了，接下来，写代码实现：
```cpp
//判断是否为奇数
bool isOddNumber(int data)
{
	if (data % 2 == 0)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//奇偶互换
void oddEvenSort(int *pData, unsigned int length)
{
	if (pData == NULL || length == 0)
		return;

	int *pBegin = pData;
	int *pEnd = pData + length - 1;

	while (pBegin < pEnd)
	{
		//如果pBegin指针指向的是奇数，正常，向后移
		if (isOddNumber(*pBegin))  
		{
			pBegin++;
		}
		//如果pEnd指针指向的是偶数，正常，向前移
		else if (!isOddNumber(*pEnd))
		{
			pEnd--;
		}
		else
		{
			//否则都不正常，交换
			int temp = *pBegin;
			*pBegin = *pEnd;
			*pEnd = temp;
		}
	}
}
```
#### 解法三

借鉴partition的实现二，我们同样可以维护两个指针i和j，一个指针指向数组的第一个元素的前一个位置，我们称之为后指针i，向右移动；一个指针指向数组第一个元素，称之为前指针j，也向右移动，且前指针先向右移动。如果前指针j指向的数字是奇数，则令i指针向右移动一位，然后交换i和j指针所各自指向的元素。

因为按照题目要求，最终是为了让奇数排在数组的前面，偶数排在数组的后面，所以i指针理应指向的就是奇数元素，j指针理应指向的就是偶数元素，所以，当j指针指向的是奇数元素时，不正常，我们就当让i++，然后交换i和j指针所各自指向的元素。

```c
//奇偶互换
void oddEvenSort2(int data[], int lo, int hi)
{
	int i = lo - 1;
	for (int j = lo; j < hi; j++)
	{
		//data[j]指向奇数，交换
		if ( isOddNumber(data[j]) )
		{
			i = i + 1;
			swap(&data[i], &data[j]);
		}
	}
	swap(&data[i + 1], &data[hi]);
}
```

### 问题扩展

细心的同学一看到上述解法二，可能会恍然大悟道，一头一尾两个指针往中间扫描，这不就是快速排序中的其中一种实现么？的确如此。

然而，普林斯顿大学教授Robert在Coursera上讲快速排序时，他提到过Unix下的qsort有一个隐藏很久的bug，那就是当快速排序遇到大量的重复元素时，其效率会非常低下。

试想一下：假设每次将第一个元素设为pivot（即比较的向标），在一次partition结束后，所有小于该元素在pivot左边，所有大于该元素位于其右边。维护两个指针，beg_ptr和end_ptr，beg_ptr从左至右移动，end_ptr从右至左移动。当beg_ptr位置的元素比pivot小时，++beg_ptr；当beg_ptr位置的元素比pivot大时，比较pivot和end_ptr位置的元素，若end_ptr位置的元素比它小，则交换beg_ptr和end_ptr位置的元素，然后++beg_ptr和--end_ptr。

在上述描述中当出现beg_ptr或end_ptr位置的元素和pivot相等时，如何操作？上述算法能保证：当pivot为5时，所有等于5的值在一次partition后都位于正确的位置上吗？

4 3 1 3 3 5 5 5 5 5 7 8 6 9

显然利用上述简单的快速排序是无法实现这个目的的。提到这个问题，其实是想说明我们早就接触过奇偶排序，那就是快速排序中的partition。将上述partition中的交换规则换成奇数和偶数即是奇偶排序。

现在回到刚才那个问题上，即快速排序中出现很多重复的元素怎么办？Dijkstra提出了一种三向快速排序算法。三向快速排序相对于传统的快速排序其需要维护3个指针：beg_ptr, cur_ptr, end_ptr。其思想如下：

初始时：beg_ptr = cur_ptr指向首位，设首位是pivot, end_ptr指向末位

更新规则：

- while cur_ptr <= end_ptr
- 若cur_ptr位置元素和beg_ptr位置元素相等，++cur_ptr, continue
- 若cur_ptr位置的元素比beg_ptr位置元素大，swap(beg_ptr, end_ptr), --end_ptr, continue
- 若cur_ptr位置元素比beg_ptr位置元素小，则swap(beg_ptr, cur_ptr), ++beg_ptr, ++cur_ptr, continue

这样做以后就可以实现partition后，所有重复的pivot都在中间。这种三向快速排序的partition还可以实现一个比奇偶排序更多的功能：

将一个整数数组，其元素分为正数，负数和0，将正数在左边，负数在右边，0在中间（可能聪明的读者会再次恍然大悟道，咦，这不就是第二章所述的荷兰国旗问题么？是的，有兴趣进一步追究的读者可以参阅2.7节）。

在C++的STL中已经实现了非常通用的partition算法，在头文件中，

```cpp
template <class ForwardIterator, class Predicate>
ForwardIterator partition(ForwardIterator first,
                          ForwardIterator last, Predicate pred) 
template <class ForwardIterator, class Predicate>
ForwardIterator stable_partition(ForwardIterator first, ForwardIterator last, 
                                 Predicate pred);
```
pred是一个仿函数或者是函数指针，其返回一个bool型变量。

下面用STL的partition实现一个奇偶排序：
```cpp
#include<iostream>
#include<algorithm>
#include<iterator>
using namespace std;

struct ODD_EVEN
{
    bool operator()(const int op)
    {
        return op&0x1;
    }
};
int main()
{
    int arr[] = {1,3,2,4,5,4,5};
    partition(arr, arr + sizeof(arr)/sizeof(int), ODD_EVEN());
    copy(arr, arr + sizeof(arr)/sizeof(int),ostream_iterator<int>(cout, " "));
    return EXIT_SUCCESS;
}
```

### 举一反三

一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序，比如： input: 1,7,-5,9,-12,15 ans: -5,-12,1,7,9,15 要求时间复杂度O(N),空间O(1)。

分析：如果本题没有这个要求“并且要求不改变原来的正负数之间相对顺序”，那么同奇偶数排序是一道题，但加上这个不能改变正负数之间的相对顺序后，便使得问题变得比较艰难了，若有兴趣，读者可以参考这篇论文《STABLE MINIMUM SPACE PARTITIONING IN LINEAR TIME》。
