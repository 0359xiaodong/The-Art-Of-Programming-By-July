## 最长回文子串的长度

### 题目描述
给定一个字符串，求它的最长回文子串的长度。

### 分析与解法
最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。

#### 解法一

那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：

```cpp
int LongestPalindrome(const char *s, int n)
{
	int i, j, max;
	if (s == 0 || n < 1)
		return 0;
	max = 0;

	for (i = 0; i < n; ++i) { // i is the middle point of the palindrome  
		for (j = 0; (i - j >= 0) && (i + j < n); ++j) // if the lengthof the palindrome is odd  
		if (s[i - j] != s[i + j])
			break;
		if (j * 2 + 1 > max)
			max = j * 2 + 1;
		for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j) // for theeven case  
		if (s[i - j] != s[i + j + 1])
			break;
		if (j * 2 + 2 > max)
			max = j * 2 + 2;
	}
	return max;
}
```

代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。


#### 解法二、O(N)解法

从上文的解法一：枚举中心位置时，我们要特别考虑长度是奇数还是偶数，所以导致在编写代码实现的时候要把奇数和偶数的情况分开编写，造成代码的拖沓冗余。是否有一种方法，可以不用管长度是奇数还是偶数，而统一处理呢？比如是否能把所有的情况全部转换为奇数处理？

答案还是肯定的。我们的确可以将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度，办法是：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。 

而且，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#

以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = "$#1#2#2#1#2#3#2#1#"，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]）。

比如S和P的对应关系：

 - S  #  1  #  2  #  2  #  1  #  2  #  3  #  2  #  1  #
 - P  1  2  1  2  5  2  1  4  1  2  1  6  1  2  1  2  1

(p.s. 可以看出，P[i]-1正好是原字符串中回文串的总长度）

那么怎么计算P[i]呢？该算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论：
- 如果mx > i，那么P[i] >= MIN(P[2 * id - i], mx - i)

```c
//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点。
if (mx - i > P[j]) 
    P[i] = P[j];
else /* P[j] >= mx - i */
    P[i] = mx - i; // P[i] >= mx - i，取最小值，之后再匹配更新。
```

当 mx - i > P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]；

![](http://www.felix021.com/blog/attachment.php?fid=447)

当 P[j] >= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] >= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。

![](http://www.felix021.com/blog/attachment.php?fid=448)

对于 mx <= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。

参考：http://bbs.dlut.edu.cn/bbstcon.php?board=Competition&gid=23474 ，或这篇文章：http://www.felix021.com/blog/read.php?2040 ，或：http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html ，待续。
